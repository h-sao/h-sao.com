+++
date = "2011-01-01T23:50:42+09:00"
draft = false
title = "[C++] 高速化について思うところ"
tags = ["cpp"]
+++


明けましておめでとうございます♪<br>
遥佐保（はるか・さお）です<br>
2011年もどうぞ、よろしくお願いします<br>
<br>
これは **C++ Advent Calendar jp 2010** (http://atnd.org/events/10573) への26日目（補欠１号！）の参加記事です<br>
<br>
C++の仕様やBoostについては全然詳しくないので、、すみません<br>
C++でのゲーム作成の時期が長かったので、高速化について、思うところを記載してみます<br>
読み物として目を通して頂ければと思います<br>
<br>
最初に。。<br>
ゲームは結果を出せれば何でもアリな世界で<br>
極端な話どんなに可動性に欠けても規格に則ってなくても<br>
良い作品が出来ればそれでヨシ！という感じなので<br>
有識者が見たら反感を買うコードがうじゃうじゃかもしれません<br>


例えば、オブジェクトを生成するためには new するわけですが、new は知ってのとおり、１フレーム内で大量に処理するには時間がかかり過ぎるし、タイミングによっては最悪、確保出来ない場合（※）もあります

>（※）確保出来なかった場合どうなるのか？ですが、  
優先順位を決めて確保の可否を判断したりします  
自分がどうしても確保されなければならないOBJの場合  
他の生きているOBJで優先順位の低いやつを探して  
そのOBJを殺し、自分に新たに割り当てたりします

そうなってくると、最初に予め new しておいて、それを使いまわすということになるのですが、そしたらコンストラクタやデストラクタに依存しない作りをルールにしておく必要があります<br>

> // もしくは、デストラクタを明示的に自力で呼ぶルール

全然事情の知らない人が、このルールだけを見たら<br>
「C++のデストラクタは信用できないから使わないんだってさ、ばかじゃないの！？」<br>
と言うかもしれないけど、ゲームはメモリ確保関連は動的に見えて、ほぼ静的なので<br>
こりゃ仕方ない<br>
<br>
そういうのって凄まじい試行錯誤から生み出された究極のソースコードなので、許してもらいたいです<br>
↓↓例えばこんな例<br>

```c
// 最初に確保
void *p_mem = operator new( max_size * sizeof( WORK ));
 WORK *box = static_cast<WORK*>( p_mem );
 for( i = 0; i < max_size; i ++ ){
    new( &box[i] ) WORK();
 }
 
 // 自分でデストラクタ呼び
 box[i].~WORK();
```

<br>

## インライン化をうまく使う

何度も何度も、１フレームに何千回と呼ばれるような処理も中にはあります<br>
その処理を関数にしておくと、もちろん関数呼び出しの分処理が遅くなってしまいます<br>
そこでインライン化です<br>
これはＣ言語のマクロ展開ほとんど同じです

> // マクロ展開はプリプロセッサで行われるけど、インライン化はコンパイラが行います  
// インライン化の方が型宣言の指定などがきっちりできるしね

結構みんなインライン化大好きなのですが、ソースコードの量が増えていくことになるので、多分あまり大きなインライン関数を書いてしまうと、キャッシュが効きにくくなったり、ソースの肥大化によるコンパイル時間の増加（そこらじゅうでincludeされてたり）など、諸刃の剣ですけどね<br>

## STLコンテナは使用用途を考えて

vector,mapなど使うのは、楽して（作業時間をかけずに）早く作りたいときだと思います<br>
例えばツール類やデバック環境での操作などなど<br>
<br>
実行速度を求めだすと、やはりこれらは使えないかな。。<br>
私的には最後はＣ風の自作コンテナが攻めるところになってくるのかと思います<br>
（そこまでやっても、実は対して高速化できないんですけどねぇ<br>
　それよりは、ポリゴン数減らす方がよっぽど速度向上になるんですけど<br>
　プログラマの頑張りどころではあるので、こういうところに行き着くのかも。。）<br>

## オーダリングテーブルなどは高速化対象になる

オーダリングテーブルとは、3D描画処理を行う場合によく使用されます<br>
自分（カメラ）から見て奥のもの、つまり遠くのものから書いていく必要があります<br>
不透明なオブジェクトばかりの場合（建物とか人物とか）ピクセル単位のＺバッファがかかるので、あまり意識しなくても良いのですが、半透明のオブジェクトを描画するときには、既に自分より奥のものを描画し終わっている必要があります<br>
<br>
というわけで、奥のものから順に描画していくための仕組みがオーダリングテーブルです<br>
プログラマはオーダリングテーブルに自分の描画したいポリゴンを登録しておけば<br>
あとは描画システムがそのテーブル順に描画していくことになります<br>
<br>
例えばＺバッファ（奥行）を1024段階(程度)に分割します<br>
自分のオブジェクトの位置（ポジション）を1024段階のどこに相当するか、割り当てます<br>
その後、奥から順にレンダリングしていきます<br>

```c
// 分かりやすく書くとvectorで
 vector <Ordering_tbl> ot;
 for( i = 0; i < ot.size(); ++ i ){
    ot[i].draw();
 }
 ```

こういう部分は高速化のやりがいがあるところです<br>
使用する立場から見ると、各ot[n]の中がさらにリンクになっていると、効果抜群です<br>
ばかみたいですが、過去に<a href="http://blog.livedoor.jp/haruka_sao/archives/51186849.html" target="_blank">自作リンク</a>作ったことがあるので、参考までに<br>
<br>
他に余談ですが、いわゆる「生ポインタ」の隠ぺいなどは、実はあまり考えてなかったような気がします<br>
生ぽ使うな！ってことは、使用者のスキルが低いときには大変有効です、新人さんと組むとか<br>
もちろん、ケアレスミスを防ぐ意味では、有識者に対しても効果ありなのですが、そこに力を注ぐ風潮は、わたしの周りにはあんまり無かったかな。。<br>
やっぱり昔ながらのアセンブラ上がりの方も多かったため、今の風潮にはマッチしてないのかもしれませんね<br>
<br>
だらだらと書いてしまいました<br>
どうぞ、今年もよろしくお願いします
