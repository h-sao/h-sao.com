<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shader on Effectiveさお</title>
    <link>http://h-sao.com/tags/shader/</link>
    <description>Recent content in Shader on Effectiveさお</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright © Sao Haruka&lt;br&gt; Powered by [Hugo](http://gohugo.io).</copyright>
    <lastBuildDate>Mon, 11 Jan 2016 18:00:00 +0900</lastBuildDate>
    
	<atom:link href="http://h-sao.com/tags/shader/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Unity] 2D Spriteにシェーダーをかける</title>
      <link>http://h-sao.com/blog/2016/01/11/unity-shader-2dsprite/</link>
      <pubDate>Mon, 11 Jan 2016 18:00:00 +0900</pubDate>
      
      <guid>http://h-sao.com/blog/2016/01/11/unity-shader-2dsprite/</guid>
      <description>今年の初めに、「Game a Week」という開発手法がすごい！っと書きました
とりあえず、週に一度は成果物を公開する、の部分を真似してみようかなと
（やってみて気が付きましたが、実は1週間って、結構長いです）
今をトキメクGame Engine: Unity について、去年から触る機会があり、ポチポチとやっております
そしてこれは既知の情報ですが、先週は2Dスプライトにシンプルなグラデーションのシェーダーを適用してみました
やってみると判るのですが、Unity ではスプライトにシンプルシェーダーだけを適用しようと思っても出来なくて、
先に結論を書いておくと、スプライトとして扱う場合は必ず何かしらのテクスチャアセットが必要でした
そのメモと感想文になります
2016年1月11日現在、Unityのバージョンは 5.3.1 です
Unity のシェーダー言語：ShaderLab Unity のシェーダーは 「ShaderLab」 という Unity オリジナルのシェーダー言語で記載することになります
といっても HLSL のラッパーのような言語なので、Unity で使うときのお作法であり、Unity と シェーダーの仲介役の言語、と思って良いみたい
最小限の ShaderLab 最小限の ShaderLab の枠組みはこんな感じ
（これより削ると、エラーが出た）
// BG_shader.shader // 最小限の ShaderLab Shader &amp;quot;Custom/BG_shader&amp;quot; { SubShader { Pass {} } }  実際に、このカスタムシェーダーをマテリアルに適用するとこんな感じ
何もしないマテリアルを作ることが出来ました
シンプルなグラデーション 今回、ゲーム背景を単純なカラーグラデーションにしようと思ったので、そういうシンプルシェーダーを書いていきます
// BG_shader.shader // 黄色くグラデーションする Shader &amp;quot;Custom/BG_shader&amp;quot; { SubShader { Pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag // VS2015のグラフィックデバックON #pragma enable_d3d11_debug_symbols struct VertexInput { float4 pos: POSITION; // 3D空間座標 float2 uv: TEXCOORD0; // テクスチャ座標 }; struct VertexOutput { float4 v: SV_POSITION; // 2D座標 float2 uv: TEXCOORD0; // テクスチャ座標 }; // 頂点 shader VertexOutput vert(VertexInput input) { VertexOutput output; output.</description>
    </item>
    
  </channel>
</rss>